//
// Created by paul on 11/22/19.
//

#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <errno.h>

#include <libconfig.h>  /* used to parse the input files */

#include "argtable3.h"  /* used to parse command line options */

#include "hashstrings.h" /* local definitions */

/* global arg_xxx structs */
static struct {
	struct arg_lit  * help;
	struct arg_lit  * version;
	struct arg_str  * extn;
	struct arg_file * file;
    struct arg_end  * end;
} gOption;

const char * gExecutableName;
const char * gPrefix;
FILE       * gOutputFile;

const int kHashFactor = 43;

typedef struct tSymbolEntry {
	const char *    name;
	const char *    mapsTo;
} tSymbolEntry;

tSymbolEntry gSymbolMap[256];
unsigned int        nextFreeSymbol = 0;
const unsigned int  kSymbolOffset  = 256;
const unsigned long kFieldMask     = 0b0111111111;

/*
 * lookup byte values (0-255), encoded as 7 x 9 bit fields per uint64
 * -------- ________ -------- ________ -------- ________ -------- ________
 * .ggggggg ggFFFFFF FFFeeeee eeeeDDDD DDDDDccc ccccccBB BBBBBBBa aaaaaaaa  7 fields of 9 bits each, total of 63 bits used
 */

uint64_t gCharMap[ (256 / (64 / 9)) + 1 ];


const char * kHeaderPrefix =
    "/*\n"
	"    This file was automatically generated by the %s tool.\n"
    "    Please see https://github.com/paul-chambers/HashStrings\n"
    "    **** any changes you make here will be overwritten ****\n"
    "    Please edit the original file \'%s\' instead.\n"
	"*/\n"
    "\n"
    "#ifndef Once_%08x\n"
    "#define Once_%08x\n"
    "\n"
    "#include <inttypes.h>\n"
    "\n";

const char * kInverseMapPrefix =
                   "typedef struct {\n"
                   "    unsigned long key;\n"
                   "    const char *  label;\n"
                   "} t%sHashMap;\n"
                   "\n"
                   "t%sHashMap %sHashLookup[] = {\n";

const char * kHeaderSuffix =
    "#endif\n"
    "\n"
    "/* end of automatically-generated file */\n";

/*****************************************/

const char * kGetFunction =
    "static inline unsigned short get%sWord( const unsigned char c)\n"
    "{\n"
    "    return ( ( g%sCharMap[ c/7 ] >> ((c % 7) * 9)) & 0b0111111111L);\n"
    "}\n\n";

static inline unsigned short getWord( const unsigned char c)
{
   return ( (gCharMap[ c/7 ] >> ((c % 7) * 9)) & 0b0111111111L );
}

/*****************************************/

/*
const char * kSetFunction =
    "static inline void set%sWord( const unsigned char c, unsigned short word )\n"
    "{\n"
    "    unsigned short shft = (c % 7) * 9;\n"
    "    g%sCharMap[ c/7 ] = (g%sCharMap[ c/7 ] & ~(0b0111111111L << shft)) | ((word & 0b0111111111L) << shft);\n"
    "}\n\n";
*/

static inline void setWord( const unsigned char c, const unsigned short word )
{
    unsigned short shft = (c % 7) * 9;
    gCharMap[ c/7 ] = (gCharMap[ c/7 ] & ~(0b0111111111L << shft)) | ((word & 0b0111111111L) << shft);
}

/*****************************************/

const char * kHashFunction =
    "static inline unsigned long f%sHashChar( unsigned long hash, const unsigned char c )\n"
    "{\n"
    "    return ( hash ^ ((hash * %d) + get%sWord( c ) ));\n"
    "}\n\n";

static inline unsigned long hashChar( unsigned long hash, const unsigned char c )
{
	return ( hash ^ ((hash * kHashFactor) + getWord( c ) ));
}

/*****************************************/

void printError( const char * format, ... )
{
    va_list args;
    char buffer[512];

    va_start(args, format);
    vsnprintf (buffer, sizeof(buffer), format, args);
    fprintf( stderr, "### %s: %s\n", gExecutableName, buffer );
    va_end(args);
}

int printParseError( const char *description, const char *filename, int lineNumber)
{
    int result = -1;
    FILE *stream;

    if ( filename != NULL )
    {
        stream = fopen( filename, "r" );
        if (stream != NULL)
        {
            char line[1024];
            int  i = 1;

            do {
                fgets( line, sizeof(line), stream );
            } while ( i++ < lineNumber && !feof( stream ) );

            line[ strcspn( line, "\r\n" ) ] = '\0';
            printError( "%s in %s at line %d: \"%s\"\n", description, filename, lineNumber, line);

            fclose( stream );

            result = 0;
        }
    }
    return result;
}

void printMap( void )
{
	fprintf( gOutputFile, "uint64_t g%sCharMap[] = {\n", gPrefix );
	for ( int i = 0; i < ((256/(64/9)) + 1); i++ )
    {
        fprintf( gOutputFile, "    0x%016lx%c    /*", gCharMap[i], (i < (256/(64/9)))? ',' : ' ' );

        for (unsigned int shft = 0; shft < (64 - 9); shft += 9 )
        {
            unsigned int c = (gCharMap[i] >> shft) & kFieldMask;
            if ( c < kSymbolOffset)
            {
                if ( isgraph( c ) )
                {
                    switch ( c )
                    {
                    case '\'':
                        fprintf( gOutputFile, " \'\\\'\'" );
                        break;

                    case '\\':
                        fprintf( gOutputFile, " \'\\\\\'" );
                        break;

                    default:
                        fprintf( gOutputFile, " \'%c\' ", c );
                        break;
                    }
                }
                else
                {
                    fprintf( gOutputFile, " 0x%02X", c );
                }
            }
            else
            {
                fprintf( gOutputFile, " (%s)", gSymbolMap[c - kSymbolOffset].name );
            }
        }
        fprintf( gOutputFile, " */\n" );
    }
    fprintf( gOutputFile, "};\n\n" );
}

int processMapping( config_t * config )
{
	int result = 0;
    config_setting_t * mapping;
    config_setting_t * element;

    /* start by mapping input to output,/
     * one-to-one */
    for ( unsigned int i = 0; i < 256; i++ )
    {
        setWord( i, i );
    }

    mapping = config_lookup( config, "mappings" );
    if (mapping != NULL)
    {
        if ( config_setting_is_group( mapping ) )
        {
            unsigned int i = 0;
            unsigned int j;
            int ignoreCase;

	        while ( (element = config_setting_get_elem( mapping, i )) != NULL)
            {
                const char * name = config_setting_name( element );

                switch ( config_setting_type( element ) )
                {
                case CONFIG_TYPE_BOOL:
                	if ( strcasecmp( name, "ignoreCase" ) == 0 )
	                {
		                ignoreCase = config_setting_get_bool( element );
		                if ( ignoreCase )
		                {
			                for ( j = 'A'; j <= 'Z'; j++ )
			                {
				                setWord( j, tolower(j) );
			                }
		                }
	                }
                    break;

                case CONFIG_TYPE_STRING:
                    {
                        unsigned char c;
                        unsigned char next;
                        j = 0;

                        gSymbolMap[ nextFreeSymbol ].name   = name;
                        gSymbolMap[ nextFreeSymbol ].mapsTo = config_setting_get_string( element );

                        while ( (c = gSymbolMap[ nextFreeSymbol ].mapsTo[ j++ ]) != '\0' )
                        {
                            next = gSymbolMap[ nextFreeSymbol ].mapsTo[ j ];

                            setWord( c, kSymbolOffset + nextFreeSymbol );

                            /* check for a range - a dash bracketed by two characters */
                            if ( c == '-' && j > 1 && next != '\0' )
                            {
                                /* If it's a dash (and it's not at the beginning or end of mapsTo),
                                 * then mark the run of characters between start and end (inclusive) */
                                while ( c <= next )
                                {
                                    setWord( c, kSymbolOffset + nextFreeSymbol );
                                    c++;
                                }
                            }
                        }
                        nextFreeSymbol++;
                    }
                    break;

                default:
                    printError( "unsupported mapping type in file \"%s\" at line %d",
                                config_setting_source_file( mapping ),
                                config_setting_source_line( mapping ) );
                    break;
                }
                i++;
            }

			fprintf( gOutputFile, "\ntypedef enum {\n" );
			for ( i = 0; i < nextFreeSymbol; i++ )
			{
				fprintf( gOutputFile, "    k%s%-16s = %d%c\n",
                         gPrefix, gSymbolMap[ i ].name, kSymbolOffset + i, (i < (nextFreeSymbol - 1))? ',' : ' ' );
			}
	        fprintf( gOutputFile, "} t%sMapping;\n\n", gPrefix );

			printMap();
        }
        else
        {
            printError( "mapping is not a group in file \"%s\" at line %d",
                        config_setting_source_file( mapping ),
                        config_setting_source_line( mapping ) );
        }
    }
    return result;
}

int processKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;
	config_setting_t * element;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
			int i = 0;
			const char * keyword;
			const char * hashword;
			char buffer[100];
			int keywordCount = keywords->value.list->length;

			fprintf( gOutputFile, "\ntypedef enum {\n" );
			while ((element = config_setting_get_elem( keywords, i )) != NULL)
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';
						hashword = (*src == ',') ? ++src : keyword;

						unsigned long hash = 0;
						src = hashword;
						while (*src != '\0' )
						{
							hash = hashChar( hash, *src );
							src++;
						}
						fprintf( gOutputFile, "    k%s%-14s = 0x%016lx%c    /* %s */\n",
								gPrefix, buffer, hash, (i+1 < keywordCount)? ',' : ' ', hashword );
					}
				}
				else
				{
					printError( "keyword must be a string, in file \"%s\" at line %d",
					            config_setting_source_file( element ),
					            config_setting_source_line( element ) );
				}
				i++;
			}
			fprintf( gOutputFile, "} t%sKeyword;\n\n", gPrefix );
		}
		else
		{
			printError( "\'keywords\' must be a array, in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}

int printInverseKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;
	config_setting_t * element;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
			const char * keyword;
			char buffer[100];


            fprintf( gOutputFile, "typedef enum {\n" );
            for ( int i = 0; (element = config_setting_get_elem( keywords, i )) != NULL; i++ )
            {
                if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
                {
                    keyword = config_setting_get_string( element );
                    if ( keyword != NULL)
                    {
                        char * p = strchr(keyword, ',');
                        if (p != NULL)
                        {
                            *p = '\0';
                        }
                        fprintf( gOutputFile, "    kIdx%s%-16s = %d,\n", gPrefix, keyword, i );
                    }
                }
                else
                {
                    printError( "keyword must be a string, in file \"%s\" at line %d",
                                config_setting_source_file( element ),
                                config_setting_source_line( element ));
                    result = -1;
                }
            }
            fprintf( gOutputFile, "    kIdx%sMax\n} tIdx%s;\n\n", gPrefix, gPrefix );

            fprintf( gOutputFile, kInverseMapPrefix, gPrefix, gPrefix, gPrefix );
			for ( int i = 0;
			      (element = config_setting_get_elem( keywords, i )) != NULL;
			      i++ )
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';

						fprintf( gOutputFile, "    { k%s%-16s, \"%s\" },\n",
						         gPrefix, buffer, buffer );
					}
				}
			}
			fprintf( gOutputFile, "    { 0, NULL }\n};\n\n" );
        }
		else
		{
			printError( "\'keywords\' must be a array, in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}


int processStructure( config_t * config )
{
	int result;

	config_lookup_string( config, "prefix", &gPrefix );

    /* first, we need to build the character mapping */
    result = processMapping( config );

    /* array is complete, so now we can generate the hashes */
    if ( result == 0 )
    {
    	result = processKeywords( config );
    }
    if ( result == 0 )
    {
    	result = printInverseKeywords( config );
    }

    fprintf( gOutputFile, kGetFunction,  gPrefix, gPrefix );
    fprintf( gOutputFile, kHashFunction, gPrefix, kHashFactor, gPrefix );

    return result;
}

int processHashFile( const char *filename )
{
    int result = 0;
    struct config_t config;

    config_init( &config );

    if ( config_read_file( &config, filename ) == CONFIG_TRUE )
	{
        struct timespec time;
        clock_gettime( CLOCK_REALTIME, &time );
        long stamp = time.tv_sec ^ time.tv_nsec;

		fprintf( gOutputFile, kHeaderPrefix,
                 gExecutableName, filename, stamp, stamp );
		result = processStructure( &config );
		fprintf( gOutputFile, "%s", kHeaderSuffix );
	}
    else
    {
        /* result is 0 only if the error message was output successfully  */
        /* note that config_error_file returns NULL if file doesn't exist */
        result = printParseError( config_error_text( &config ),
                                  config_error_file( &config ),
                                  config_error_line( &config ) );
        if ( result != 0 )
        {
            printError( "unable to parse \'%s\': %s",
                        filename, config_error_text( &config ) );
        }
        result = -1;
    }

    config_destroy( &config );

    return result;
}

int main( int argc, char * argv[] )
{
    int result = 0;

    gExecutableName = strrchr( argv[0], '/' );
    /* If we found a slash, increment past it.
     * If there's no slash, point at the full argv[0] */
    if ( gExecutableName++ == NULL )
        { gExecutableName = argv[0]; }

    gOutputFile = stdout;

    /* the global arg_xxx structs above are initialised within the argtable */
    void * argtable[] =
    {
        gOption.help    = arg_litn(  NULL, "help",      0, 1, "display this help (and exit)"),
        gOption.version = arg_litn(  NULL, "version",   0, 1, "display version info (and exit)"),
	    gOption.extn    = arg_strn(  "x",  "extension", "<extension>",  0, 1, "set the extension to use for output files"),
        gOption.file    = arg_filen( NULL, NULL,        "<file>", 1, 999, "input files"),

        gOption.end     = arg_end( 20 )
    };

    int nerrors = arg_parse( argc, argv, argtable );

    /* special case: '--help' takes precedence over everything else */
    if ( gOption.help->count > 0 )
    {
        fprintf( stdout, "Usage: %s", gExecutableName );
        arg_print_syntax( stdout, argtable, "\n" );
        fprintf( stdout, "process hash file into a header file.\n\n" );
        arg_print_glossary( stdout, argtable, "  %-25s %s\n" );
        fprintf( stdout, "\n" );

        result = 0;
    }
    else if ( gOption.version->count > 0 )   /* ditto for '--version' */
    {
        fprintf( stdout, "%s, version %s\n", gExecutableName, "(to do)" );
    }
    else if (nerrors > 0) 	/* If the parser returned any errors then display them and exit */
    {
        /* Display the error details contained in the arg_end struct.*/
        arg_print_errors( stdout, gOption.end, gExecutableName );
        fprintf( stdout, "Try '%s --help' for more information.\n", gExecutableName );
        result = 1;
    }
    else
    {
        result = 0;
        int i  = 0;

        gOutputFile = NULL;

	    const char * extension = ".h";
	    if ( gOption.extn->count != 0 )
	    {
		    extension = *gOption.extn->sval;
	    }

        while ( i < gOption.file->count && result == 0 )
        {
	        char output[FILENAME_MAX];
	        strncpy( output, gOption.file->filename[i], sizeof(output) );


	        char * p = strrchr( output, '.' );
            if ( p != NULL )
	        {
		        strncpy( p, extension, &output[ sizeof(output) - 1 ] - p );
	        }

	        gOutputFile = fopen( output, "w" );
	        if ( gOutputFile == NULL)
	        {
		        fprintf( stderr, "### unable to open \'%s\' (%d: %s)\n",
		                 output, errno, strerror(errno) );
		        result = errno;
	        }

			if ( result == 0 )
			{
				result = processHashFile( gOption.file->filename[i] );
			}
            i++;

			fclose( gOutputFile );
        }
    }

    /* release each non-null entry in argtable[] */
    arg_freetable( argtable, sizeof(argtable) / sizeof(argtable[0]) );

    return result;
}
