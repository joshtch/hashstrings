//
// Created by paul on 11/22/19.
//

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

#include <libconfig.h>      /* used to parse the input files */

#include "argtable3.h"      /* used to parse command line options */
#include "btree/btree.h"    /* B+ Tree support */

#include "libhashstrings.h"


typedef struct {
    const char * executableName;
    const char * prefix;
    FILE *       outputFile;

    unsigned int arrayCount;
    unsigned int arrayIndex;
    tRecord **   array;
    tRecord **   skipTable;
} tGlobals;

tGlobals globals;

/* global arg_xxx structs */
static struct {
	struct arg_lit  * help;
	struct arg_lit  * version;
	struct arg_str  * extn;
	struct arg_file * file;
    struct arg_end  * end;
} gOption;

typedef struct tSymbolEntry {
	const char *    name;
	const char *    mapsTo;
} tSymbolEntry;

tSymbolEntry gSymbolMap[256];
unsigned int        nextFreeSymbol = 0;
const unsigned int  kSymbolOffset  = 256;

/* B+ Tree root bptNode */
tNode * root;

/*
 * lookup byte values (0-255), encoded as 7 x 9 bit fields per uint64
 * -------- ________ -------- ________ -------- ________ -------- ________
 * .ggggggg ggFFFFFF FFFeeeee eeeeDDDD DDDDDccc ccccccBB BBBBBBBa aaaaaaaa
 */

tCharMap gCharMap[ (256 / (64 / 9)) + 1 ];

const char * kHeaderPrefix =
    "/*\n"
	"    This file was automatically generated by the %s tool.\n"
    "    Please see https://github.com/paul-chambers/HashStrings\n"
    "    **** any changes you make here will be overwritten ****\n"
    "    Please edit the original file \'%s\' instead.\n"
	"*/\n"
    "\n"
    "#ifndef Once_%08x\n"
    "#define Once_%08x\n"
    "\n"
    "#include <libhashstrings.h>\n"
    "\n";

const char * kHashEnumSuffix =
        "    k%sMaxIndex = %d\n"
        "} t%sIndex;\n"
        "\n";

const char * kHashMapPrefix =
        "typedef struct {\n"
        "    tHash hash;\n"
        "    t%sIndex index;\n"
        "    unsigned short left, right;\n"
        "} tMap%sHash;\n"
        "\n"
        "tMap%sHash map%sHash[] = {\n";

const char * kInverseMapPrefix =
    "const char * lookup%sAsString[] =\n"
    "{\n";

const char * kHeaderSuffix =
    "#endif\n"
    "\n"
    "/* end of automatically-generated file */\n";

/*****************************************/

void printError( const char * format, ... )
{
    va_list args;
    char buffer[512];

    va_start(args, format);
    vsnprintf (buffer, sizeof(buffer), format, args);
    fprintf( stderr, "### %s: %s\n", globals.executableName, buffer );
    va_end(args);
}

int printParseError( const char *description, const char *filename, int lineNumber)
{
    int result = -1;

    if ( filename != NULL )
    {
        FILE * stream = fopen( filename, "r" );
        if (stream != NULL)
        {
            char line[1024];
            int  i = 1;

            do {
                fgets( line, sizeof(line), stream );
            } while ( i++ < lineNumber && !feof( stream ) );

            line[ strcspn( line, "\r\n" ) ] = '\0';
            printError( "%s in %s at line %d: \"%s\"\n",
                        description, filename, lineNumber, line);

            fclose( stream );

            result = 0;
        }
    }
    return result;
}

void printMap( void )
{
	fprintf( globals.outputFile, "uint64_t g%sCharMap[] = {\n", globals.prefix );
	for ( int i = 0; i < ((256/(64/9)) + 1); i++ )
    {
        fprintf( globals.outputFile, "    0x%016lx%c    /*", gCharMap[i], (i < (256/(64/9)))? ',' : ' ' );

        for (unsigned int shft = 0; shft < (64 - 9); shft += 9 )
        {
            unsigned int c = (gCharMap[i] >> shft) & 0x01ffL;
            if ( c < kSymbolOffset)
            {
                if ( isgraph( c ) )
                {
                    switch ( c )
                    {
                    case '\'':
                        fprintf( globals.outputFile, " \'\\\'\'" );
                        break;

                    case '\\':
                        fprintf( globals.outputFile, " \'\\\'" );
                        break;

                    default:
                        fprintf( globals.outputFile, " \'%c\' ", c );
                        break;
                    }
                }
                else
                {
                    fprintf( globals.outputFile, " 0x%02X", c );
                }
            }
            else
            {
                fprintf( globals.outputFile, " (%s)", gSymbolMap[c - kSymbolOffset].name );
            }
        }
        fprintf( globals.outputFile, " */\n" );
    }
    fprintf( globals.outputFile, "};\n\n" );
}

int processMapping( config_t * config )
{
	int result = 0;
    config_setting_t * mapping;

    /* start by mapping input to output,/
     * one-to-one */
    for ( unsigned int i = 0; i < 256; i++ )
    {
        setCharMap( gCharMap, i, i );
    }

    mapping = config_lookup( config, "mappings" );
    if (mapping != NULL)
    {
        if ( config_setting_is_group( mapping ) )
        {
            config_setting_t * element;
            unsigned int i = 0;
            unsigned int j;
            int ignoreCase;

	        while ( (element = config_setting_get_elem( mapping, i )) != NULL)
            {
                const char * name = config_setting_name( element );

                switch ( config_setting_type( element ) )
                {
                case CONFIG_TYPE_BOOL:
                	if ( strcasecmp( name, "ignoreCase" ) == 0 )
	                {
		                ignoreCase = config_setting_get_bool( element );
		                if ( ignoreCase )
		                {
			                for ( j = 'A'; j <= 'Z'; j++ )
			                {
                                setCharMap( gCharMap, j, tolower( j ));
			                }
		                }
	                }
                    break;

                case CONFIG_TYPE_STRING:
                    {
                        unsigned char c;
                        j = 0;

                        gSymbolMap[ nextFreeSymbol ].name   = name;
                        gSymbolMap[ nextFreeSymbol ].mapsTo = config_setting_get_string( element );

                        while ( (c = gSymbolMap[ nextFreeSymbol ].mapsTo[ j++ ]) != '\0' )
                        {
                            unsigned char next = gSymbolMap[ nextFreeSymbol ].mapsTo[ j ];

                            setCharMap( gCharMap, c, kSymbolOffset + nextFreeSymbol );

                            /* check for a range - a dash bracketed by two characters */
                            if ( c == '-' && j > 1 && next != '\0' )
                            {
                                /* If it's a dash (and it's not at the beginning or end of mapsTo),
                                 * then mark the run of characters between start and end (inclusive) */
                                while ( c <= next )
                                {
                                    setCharMap( gCharMap, c, kSymbolOffset + nextFreeSymbol );
                                    c++;
                                }
                            }
                        }
                        nextFreeSymbol++;
                    }
                    break;

                default:
                    printError( "unsupported mapping type in file \"%s\" at line %d",
                                config_setting_source_file( mapping ),
                                config_setting_source_line( mapping ) );
                    break;
                }
                i++;
            }

			fprintf( globals.outputFile, "\ntypedef enum {\n" );
			for ( i = 0; i < nextFreeSymbol; i++ )
			{
				fprintf( globals.outputFile, "    k%s%-16s = %u,\n",
                         globals.prefix, gSymbolMap[ i ].name, kSymbolOffset + i );
			}
	        fprintf( globals.outputFile, "    k%sMax\n} t%sMapping;\n\n",
                     globals.prefix, globals.prefix );

			printMap();
        }
        else
        {
            printError( "mapping is not a group in file \"%s\" at line %d",
                        config_setting_source_file( mapping ),
                        config_setting_source_line( mapping ) );
        }
    }
    return result;
}

int compareRecords( const void * a, const void * b, void * udata )
{
    int   result;
    const tRecord * recordA = a;
    const tRecord * recordB = b;
    (void) udata;

    result = recordA->hash < recordB->hash? -1 : (recordA->hash > recordB->hash);

    return result;
}

bool storeRecord( const void * a, void * udata )
{
    tGlobals * g      = udata;

    if ( g->arrayIndex < g->arrayCount )
    {
        g->array[ g->arrayIndex++ ] = (tRecord *) a;
    }
    return true;
}

void fillTable( unsigned int level,
                char hand,
                unsigned int offset,
                unsigned int length )
{
    unsigned int split = (length) / 2;

    globals.array[offset + split]->level = level;
    globals.array[offset + split]->hand  = hand;

    globals.skipTable[ globals.arrayIndex ] = globals.array[ offset + split ];
    globals.arrayIndex++;

    unsigned int lenL = split;
    if ( lenL > 0 )
    {
        globals.array[split + offset]->lower = globals.arrayIndex;
        fillTable( level + 1, 'l', offset, lenL );
    }
    else {
        globals.array[split + offset]->lower = 0;
    }

    unsigned int lenR = length - (split + 1);
    if ( lenR > 0 )
    {
        globals.array[split + offset]->higher = globals.arrayIndex;
        fillTable( level + 1, 'r', offset + split + 1, lenR );
    }
    else {
        globals.array[split + offset]->higher = 0;
    }
}


int processKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
            config_setting_t * element;
            const char * keyword;
            unsigned int i = 0;
			char buffer[100];

            struct btree * tree;
            tRecord        record;

            /* create a b-tree */
            tree = btree_new( sizeof( tRecord ), 0,
                              compareRecords, &globals );

            fprintf( globals.outputFile, "\ntypedef enum {\n" );
			while ((element = config_setting_get_elem( keywords, i )) != NULL)
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';

                        fprintf( globals.outputFile,
                                 "    k%s%-16s = %u,\n",
                                 globals.prefix, buffer, i );

                        /* if there's a comma, hash the remainder
                         * instead of hashing the keyword itself */
                        if ( *src == ',' )
                            { ++src; }
                        else
                            { src = buffer; }

                        while ( *src != '\0' )
                        {
                            tHash hash = 0;
                            const char * hashedString = src;
                            while ( *src != '\0' && *src != ',' )
                            {
                                hash = hashChar( hash, remapChar( gCharMap, *src ) );
                                src++;
                            }

                            /* insert into B+Tree */
                            record.hash = hash;
                            record.hashedString = strndup( hashedString,
                                                           src - hashedString );
                            record.name = strdup( buffer );
                            btree_set( tree, &record );

                            if ( *src != '\0' )
                            { ++src; }
                        }
					}
				}
				else
				{
					printError( "keyword must be a string, in file \"%s\" at line %d",
					            config_setting_source_file( element ),
					            config_setting_source_line( element ) );
				}
				i++;
			}

            fprintf( globals.outputFile, kHashEnumSuffix,
                     globals.prefix, i, globals.prefix );


            fprintf( globals.outputFile, kHashMapPrefix, globals.prefix,
                     globals.prefix, globals.prefix, globals.prefix );

            globals.arrayIndex = 0;
            globals.arrayCount = btree_count( tree );
            if ( globals.arrayCount > 0)
            {
                globals.array = calloc( globals.arrayCount,
                                        sizeof( tRecord * ) );
                if ( globals.array != NULL )
                {
                    btree_ascend( tree, NULL, storeRecord, &globals );

                    globals.skipTable = calloc( globals.arrayCount,
                                                sizeof( tRecord * ) );
                    if ( globals.skipTable != NULL)
                    {
                        globals.arrayIndex = 0;
                        fillTable( 0, '+', 0, globals.arrayCount );

                        for ( i = 0; i < globals.arrayCount; i++ )
                        {
                            fprintf( globals.outputFile,
                                     "/* %2u:%c */    { 0x%016lx, k%s%s, %u, %u },\n",
                                     i,
                                     globals.skipTable[i]->hand,
                                     globals.skipTable[i]->hash,
                                     globals.prefix,
                                     globals.skipTable[i]->name,
                                     globals.skipTable[i]->lower,
                                     globals.skipTable[i]->higher );
                        }

                        /* do a quick sanity check */
                        for ( i = 0; i < globals.arrayCount; i++ )
                        {
                            tHash hash = globals.array[i]->hash;
                            tRecord * record = findHash( globals.skipTable, hash );
                            fprintf( stderr, "0x%016lx %s\n",
                                     hash,
                                     record != NULL? record->name : "not found" );
                        }
                    }
                }
            }
            fprintf( globals.outputFile, "};\n\n" );
        }
		else
		{
			printError( "\'keywords\' must be a array, in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}

int printInverseKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
			const char * keyword;
            config_setting_t * element;
            char buffer[100];

            fprintf( globals.outputFile, kInverseMapPrefix,
                     globals.prefix, globals.prefix, globals.prefix );
			for ( int i = 0;
			      (element = config_setting_get_elem( keywords, i )) != NULL;
			      i++ )
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';

						fprintf( globals.outputFile,
                                 "    [ k%s%-16s ] = \"%s\",\n",
						         globals.prefix, buffer, buffer );
					}
				}
			}
            fprintf( globals.outputFile,
                     "    [ k%sMaxIndex ] = NULL\n};\n\n",
                     globals.prefix);
        }
		else
		{
			printError( "\'keywords\' must be a array,"
                        " in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}


int processStructure( config_t * config )
{
	int result;

	config_lookup_string( config, "prefix", &globals.prefix );

    /* first, we need to build the character mapping */
    result = processMapping( config );

    /* array is complete, so now we can generate the hashes */
    if ( result == 0 )
    {
    	result = processKeywords( config );
    }
    if ( result == 0 )
    {
    	result = printInverseKeywords( config );
    }

    return result;
}

int processHashFile( const char *filename )
{
    int result;
    struct config_t config;

    config_init( &config );

    if ( config_read_file( &config, filename ) == CONFIG_TRUE )
	{
        struct timespec time;
        clock_gettime( CLOCK_REALTIME, &time );
        long stamp = time.tv_sec ^ time.tv_nsec;

		fprintf( globals.outputFile, kHeaderPrefix,
                 globals.executableName, filename, stamp, stamp );
		result = processStructure( &config );
		fprintf( globals.outputFile, "%s", kHeaderSuffix );
	}
    else
    {
        /* result is 0 only if the error message was output successfully  */
        /* note that config_error_file returns NULL if file doesn't exist */
        result = printParseError( config_error_text( &config ),
                                  config_error_file( &config ),
                                  config_error_line( &config ) );
        if ( result != 0 )
        {
            printError( "unable to parse \'%s\': %s",
                        filename, config_error_text( &config ) );
        }
        result = -1;
    }

    config_destroy( &config );

    return result;
}

int main( int argc, char * argv[] )
{
    int result = 0;

    globals.executableName = strrchr( argv[0], '/' );
    /* If we found a slash, increment past it.
     * If there's no slash, point at the full argv[0] */
    if ( globals.executableName++ == NULL )
        { globals.executableName = argv[0]; }

    globals.outputFile = stdout;

    /* the global arg_xxx structs above are initialised within the argtable */
    void * argtable[] =
    {
        gOption.help    = arg_litn( NULL, "help",
                                    0, 1,
                                    "display this help (and exit)"),
        gOption.version = arg_litn( NULL, "version",
                                    0, 1,
                                    "display version info (and exit)"),
	    gOption.extn    = arg_strn( "x",  "extension",
                                    "<extension>",
                                    0, 1,
                                    "set the extension to use for output files"),
        gOption.file    = arg_filen( NULL, NULL,
                                     "<file>",
                                     1, 999,
                                     "input files"),

        gOption.end     = arg_end( 20 )
    };

    int nerrors = arg_parse( argc, argv, argtable );

    /* special case: '--help' takes precedence over everything else */
    if ( gOption.help->count > 0 )
    {
        fprintf( stdout, "Usage: %s", globals.executableName );
        arg_print_syntax( stdout, argtable, "\n" );
        fprintf( stdout, "process hash file into a header file.\n\n" );
        arg_print_glossary( stdout, argtable, "  %-25s %s\n" );
        fprintf( stdout, "\n" );

        result = 0;
    }
    else if ( gOption.version->count > 0 )   /* ditto for '--version' */
    {
        fprintf( stdout, "%s, version %s\n", globals.executableName, "(to do)" );
    }
    else if (nerrors > 0) 	/* If the parser returned any errors then display them and exit */
    {
        /* Display the error details contained in the arg_end struct.*/
        arg_print_errors( stdout, gOption.end, globals.executableName );
        fprintf( stdout, "Try '%s --help' for more information.\n", globals.executableName );
        result = 1;
    }
    else
    {
        result = 0;
        int i  = 0;

        globals.outputFile = NULL;

	    const char * extension = ".h";
	    if ( gOption.extn->count != 0 )
	    {
		    extension = *gOption.extn->sval;
	    }

        while ( i < gOption.file->count && result == 0 )
        {
	        char output[FILENAME_MAX];
	        strncpy( output, gOption.file->filename[i], sizeof(output) );


	        char * p = strrchr( output, '.' );
            if ( p != NULL )
	        {
		        strncpy( p, extension, &output[ sizeof(output) - 1 ] - p );
	        }

	        globals.outputFile = fopen( output, "w" );
	        if ( globals.outputFile == NULL)
	        {
		        fprintf( stderr, "### unable to open \'%s\' (%d: %s)\n",
		                 output, errno, strerror(errno) );
		        result = errno;
	        }

			if ( result == 0 )
			{
				result = processHashFile( gOption.file->filename[i] );
			}
            i++;

			fclose( globals.outputFile );
        }
    }

    /* release each non-null entry in argtable[] */
    arg_freetable( argtable, sizeof(argtable) / sizeof(argtable[0]) );

    return result;
}
