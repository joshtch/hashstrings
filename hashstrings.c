//
// Created by paul on 11/22/19.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <stdarg.h>

#include <libconfig.h>  /* used to parse the input files */

#include "argtable3.h"  /* used to parse command line options */

#include "hashstrings.h" /* local definitions */

/* global arg_xxx structs */
static struct {
    struct arg_lit *verb, *help, *version;
    struct arg_int *level;
    struct arg_file *o, *file;
    struct arg_end *end;
} gOption;


typedef struct tSymbolEntry {
	struct tSymbolEntry * next;
	char * name;
	const char * mappedTo;
} tSymbolEntry;

tSymbolEntry * gSymbolRoot = NULL;

struct {
	char byte;
	tSymbolEntry * symbol;
} gCharMap[256];

const char * gHeaderPrefix =
  "/* automatically generated by the HashStrings tool.\n"
  "   **** any changes will be overwritten ****\n"
  "   please edit the corresponding input file instead */\n\n";

const char * gHeaderSuffix =
  "\n/* end of automatically-generated file */\n";

const char * gExecutableName;
const char * gPrefix;

const int _hash_factor = 43;
typedef unsigned long tHash;

tHash hashChar(tHash hash, char c )
{
	return ( hash * _hash_factor ) ^ gCharMap[ (unsigned char)c ];
}

void printError( const char * format, ... )
{
    va_list args;
    char buffer[512];

    va_start(args, format);
    vsnprintf (buffer, sizeof(buffer), format, args);
    fprintf( stderr, "### %s: %s\n", gExecutableName, buffer );
    va_end(args);
}

int printParseError( const char *description, const char *filename, int lineNumber)
{
    int result = -1;
    FILE *stream;

    if ( filename != NULL )
    {
        stream = fopen( filename, "r" );
        if (stream != NULL)
        {
            char line[1024];
            int  i = 1;

            do {
                fgets( line, sizeof(line), stream );
            } while ( i++ < lineNumber && !feof( stream ));

            line[ strcspn( line, "\r\n" ) ] = '\0';
            printError( "%s in %s at line %d: \"%s\"\n", description, filename, lineNumber, line);

            fclose( stream );

            result = 0;
        }
    }
    return result;
}

void printMap( void )
{
	printf( "unsigned char %sMap[] = {\n", gPrefix );
	for ( int i = 0; i < 256; i++ )
	{
		char slug[32];
		if ( gCharMap[i].symbol != NULL )
		{
			snprintf( slug, sizeof(slug), "%s%s", gPrefix, gCharMap[i].symbol->name );
		}
		else
		{
			unsigned char c = gCharMap[i].byte;
			switch (c)
			{
			case '\'':
				snprintf( slug, sizeof(slug), "\'\\\'\'");
				break;

			case '\\':
				snprintf( slug, sizeof(slug), "\'\\\\\'");
				break;

			default:
				if ( isgraph(c) )
				{
					snprintf( slug, sizeof(slug), "\'%c\'", c);
				}
				else
				{
					snprintf( slug, sizeof(slug), "0x%02X", c);
				}
				break;
			}
		}
		printf("%20s%s", slug, (i < 255 ? ((i % 4) == 3? ",\n" : ",") : "\n};\n") );
	}
}

int processMapping( config_t * config )
{
    config_setting_t * mapping;
    config_setting_t * element;

	/* initialize the map to one-to-one */
    for (unsigned int i = 0; i < 256; i++ )
    {
        gCharMap[i].byte = (char)i;
        gCharMap[i].symbol = NULL;
    }

    mapping = config_lookup( config, "mappings" );
    if (mapping != NULL)
    {
        if (config_setting_is_group( mapping ))
        {
            int i = 0;
	        int ignoreCase;
            char * name;
	        tSymbolEntry * symbol;

	        while ( (element = config_setting_get_elem( mapping, i )) != NULL)
            {
                name = config_setting_name( element );

                switch ( config_setting_type( element ) )
                {
                case CONFIG_TYPE_BOOL:
                	if ( strcasecmp( name, "ignoreCase" ) == 0 )
	                {
		                ignoreCase = config_setting_get_bool( element );
		                if ( ignoreCase )
		                {
			                for ( int i = 'A'; i <= 'Z'; i++ )
			                {
				                gCharMap[i].byte = tolower(i);
			                }
		                }
	                }
                    break;

                case CONFIG_TYPE_STRING:
                	symbol = malloc( sizeof(tSymbolEntry) );
					if ( symbol != NULL )
					{
						symbol->name = name;
						symbol->mappedTo = config_setting_get_string( element );

						{
							int i = 0;
							int j;
							while ( (j = symbol->mappedTo[i]) != '\0' )
							{
								unsigned char start = 0, end;
								/* check for a range */
								if ( j == '-' )
								{
									start = symbol->mappedTo[i - 1];
									end   = symbol->mappedTo[i + 1];
									if (start > end)
									{
										start = end;
										end = symbol->mappedTo[i - 1];
									}
								}
								/* if it's a dash, and it's not at the beginning or end of mappedTo,
								 * then process the range of characters between start and end */
								if ( j == '-' && i > 0 && (start != '\0') )
								{
									for ( int k = start; k <= end; k++ )
									{
										gCharMap[k].byte   = symbol->mappedTo[0];
										gCharMap[k].symbol = symbol;
									}
									i++;
								}
								else
								{
									gCharMap[j].byte   = symbol->mappedTo[0];
									gCharMap[j].symbol = symbol;
								}
								i++;
							}
						}

						symbol->next = gSymbolRoot;
						gSymbolRoot = symbol;
					}
                    break;

                default:
                    printError( "unsupported mapping type in file \"%s\" at line %d",
                                 config_setting_source_file( mapping ),
                                 config_setting_source_line( mapping ) );
                    break;
                }
                i++;
            }

			printf( "\nenum %sMappings {\n", gPrefix );
	        symbol = gSymbolRoot;
			while (symbol != NULL)
			{
				printf( "    %s%s = \'%c\'%s\n", gPrefix, symbol->name, symbol->mappedTo[0], (symbol->next != NULL)? "," : "\n};\n" );
				symbol = symbol->next;
			}

			printMap();

	        symbol = gSymbolRoot;
			gSymbolRoot = NULL;
			while (symbol != NULL)
			{
				tSymbolEntry * next;
				next = symbol->next;
				free( symbol );
				symbol = next;
			}
        }
        else
        {
            printError( "mapping is not a group in file \"%s\" at line %d",
                        config_setting_source_file( mapping ),
                        config_setting_source_line( mapping ) );
        }
    }
}

int processKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;
	config_setting_t * element;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
			int i = 0;
			const char * keyword;
			const char * hashword;
			char buffer[32];

			printf( "\nenum %sHash {\n", gPrefix );
			while ( (element = config_setting_get_elem( keywords, i )) != NULL)
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int    cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';
						hashword = (*src == ',') ? ++src : keyword;

						tHash hash = 0;
						src = buffer;
						while (*src != '\0' )
						{
							hash = hashChar( hash, *src );
							src++;
						}
						printf( "    %s%-16s = 0x%016lx,    /* %s */\n", gPrefix, buffer, hash, hashword );
					}
				}
				else
				{
					printError( "keyword must be a string, in file \"%s\" at line %d",
					            config_setting_source_file( element ),
					            config_setting_source_line( element ) );
				}
				i++;
			}
			printf("};\n\n");
		}
		else
		{
			printError( "\'keywords\' must be a array, in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}

int processStructure( config_t * config )
{
	int result;

	config_lookup_string( config, "prefix", &gPrefix );

	fprintf( stdout, "%s", gHeaderPrefix );

	fprintf( stdout, gHashFunction, _hash_factor );
    /* first, we need to build the character mapping */
    result = processMapping( config );
    /* array is complete, so now we can generate the hashes */
    if ( result == 0 )
    {
    	result = processKeywords( config );
    }
    if ( result == 0 )
    {
	    fprintf( stdout, "%s", gHeaderSuffix );
    }

    return result;
}

int processHashFile( const char *filename )
{
    int result = 0;
    struct config_t config;

    config_init( &config );

    if ( config_read_file( &config, filename ) == CONFIG_TRUE )
	{
		result = processStructure( &config );
	}
    else
    {
        /* result is 0 only if the error message was output successfully  */
        /* note that config_error_file returns NULL if file doesn't exist */
        result = printParseError( config_error_text( &config ),
                                  config_error_file( &config ),
                                  config_error_line( &config ) );
        if ( result != 0 )
        {
            printError( "unable to parse \'%s\': %s", filename, config_error_text( &config ) );
        }
        result = -1;
    }

    config_destroy( &config );

    return result;
}

int main( int argc, char * argv[] )
{
    int result;
    FILE * cmdOut = stdout;
    gExecutableName = strrchr( argv[0], '/' );
    /* if we found a slash, increment past it, else point at the full argv[0] */
    if ( gExecutableName++ == NULL )
        { gExecutableName = argv[0]; }

    /* the global arg_xxx structs above are initialised within the argtable */
    void * argtable[] =
    {
        gOption.help    = arg_litn(  NULL,  "help",     0,         1,  "display this help (and exit)"),
        gOption.version = arg_litn(  NULL,  "version",  0,         1,  "display version info (and exit)"),
        gOption.file    = arg_filen( NULL,  NULL,       "<file>",  1,  100, "input files"),

        gOption.end     = arg_end( 20 )
    };

    int nerrors = arg_parse( argc, argv, argtable );

    if ( gOption.help->count > 0 ) 	/* special case: '--help' takes precedence over everything else */
    {
        fprintf( cmdOut, "Usage: %s", gExecutableName );
        arg_print_syntax( cmdOut, argtable, "\n" );
        fprintf( cmdOut, "Demonstrate command-line parsing in argtable3.\n\n" );
        arg_print_glossary( cmdOut, argtable, "  %-25s %s\n" );
        fprintf( cmdOut, "\n" );

        result = 0;
    }
    else if ( gOption.version->count > 0 )   /* ditto for '--version' */
    {
        fprintf( cmdOut, "%s, version %s\n", gExecutableName, "(to do)" );
    }
    else if (nerrors > 0) 	/* If the parser returned any errors then display them and exit */
    {
        /* Display the error details contained in the arg_end struct.*/
        arg_print_errors( cmdOut, gOption.end, gExecutableName );
        fprintf( cmdOut, "Try '%s --help' for more information.\n", gExecutableName );
        result = 1;
    }
    else
    {
        result = 0;
        int i = 0;

        while ( i < gOption.file->count && result == 0 )
        {
            result = processHashFile( gOption.file->filename[i] );
            i++;
        }
    }

    /* release each non-null entry in argtable[] */
    arg_freetable( argtable, sizeof(argtable) / sizeof(argtable[0]) );

    return result;
}
