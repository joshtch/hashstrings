//
// Created by paul on 11/22/19.
//

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <errno.h>

#include <libconfig.h>  /* used to parse the input files */

#include "argtable3.h"  /* used to parse command line options */

#include "hashstrings.h" /* local definitions */

/* global arg_xxx structs */
static struct {
	struct arg_lit  * help;
	struct arg_lit  * version;
	struct arg_str  * extn;
	struct arg_file * file;
    struct arg_end  * end;
} gOption;

typedef struct tSymbolEntry {
	struct tSymbolEntry * next;
	char * name;
	const char * mappedTo;
} tSymbolEntry;

tSymbolEntry * gSymbolRoot = NULL;

struct {
	char byte;
	tSymbolEntry * symbol;
} gCharMap[256];

const char * gHeaderPrefix =
    "/*\n"
	"   This file was automatically generated by the %s tool.\n"
    "   Please see https://github.com/paul-chambers/HashStrings\n"
    "   **** any changes you make here will be overwritten ****\n"
    "   Please edit the original file \'%s\' instead.\n"
	" */\n\n";

const char * gHeaderSuffix =
    "\n/* end of automatically-generated file */\n";

const char * gHashFunction =
	"static inline tHash f%sHashChar( tHash hash, const unsigned char c )\n"
	"{\n"
	"    return ( hash ^ ((hash * %d) + k%sMap[ c ]) );\n"
	"}\n";

const char * gInverseMapPrefix =
	"typedef struct {\n"
	"    tHash   key;\n"
	"    string  label;\n"
	"} t%sHashMapping;\n\n"
    "t%sHashMapping %sHashLookup[] = {\n";

const char * gExecutableName;
const char * gPrefix;
FILE * gOutputFile;

const int _hash_factor = 43;
typedef unsigned long tHash;

static inline tHash hashChar(tHash hash, const char c )
{
	return ( hash ^ ((hash * _hash_factor) + gCharMap[ (unsigned char)c ].byte) );
}

void printError( const char * format, ... )
{
    va_list args;
    char buffer[512];

    va_start(args, format);
    vsnprintf (buffer, sizeof(buffer), format, args);
    fprintf( stderr, "### %s: %s\n", gExecutableName, buffer );
    va_end(args);
}

int printParseError( const char *description, const char *filename, int lineNumber)
{
    int result = -1;
    FILE *stream;

    if ( filename != NULL )
    {
        stream = fopen( filename, "r" );
        if (stream != NULL)
        {
            char line[1024];
            int  i = 1;

            do {
                fgets( line, sizeof(line), stream );
            } while ( i++ < lineNumber && !feof( stream ) );

            line[ strcspn( line, "\r\n" ) ] = '\0';
            printError( "%s in %s at line %d: \"%s\"\n", description, filename, lineNumber, line);

            fclose( stream );

            result = 0;
        }
    }
    return result;
}

void printMap( void )
{
	fprintf( gOutputFile, "const unsigned char k%sMap[] = {\n", gPrefix );
	for ( int i = 0; i < 256; i++ )
	{
		char slug[32];
		if ( gCharMap[i].symbol != NULL )
		{
			snprintf( slug, sizeof(slug), "k%s%s", gPrefix, gCharMap[i].symbol->name );
		}
		else
		{
			unsigned char c = gCharMap[i].byte;
			switch (c)
			{
			case '\'':
				snprintf( slug, sizeof(slug), "\'\\\'\'");
				break;

			case '\\':
				snprintf( slug, sizeof(slug), "\'\\\\\'");
				break;

			default:
				if ( isgraph(c) )
				{
					snprintf( slug, sizeof(slug), "\'%c\'", c);
				}
				else
				{
					snprintf( slug, sizeof(slug), "0x%02X", c);
				}
				break;
			}
		}
		fprintf( gOutputFile, "%20s%s", slug, (i < 255 ? ((i % 4) == 3? ",\n" : ",") : "\n};\n") );
	}
}



int processMapping( config_t * config )
{
	int result = 0;
    config_setting_t * mapping;
    config_setting_t * element;

	/* initialize the map to one-to-one */
    for (unsigned int i = 0; i < 256; i++ )
    {
        gCharMap[i].byte = (char)i;
        gCharMap[i].symbol = NULL;
    }

    mapping = config_lookup( config, "mappings" );
    if (mapping != NULL)
    {
        if (config_setting_is_group( mapping ))
        {
            int i = 0;
	        int ignoreCase;
            char * name;
	        tSymbolEntry * symbol;

	        while ( (element = config_setting_get_elem( mapping, i )) != NULL)
            {
                name = config_setting_name( element );

                switch ( config_setting_type( element ) )
                {
                case CONFIG_TYPE_BOOL:
                	if ( strcasecmp( name, "ignoreCase" ) == 0 )
	                {
		                ignoreCase = config_setting_get_bool( element );
		                if ( ignoreCase )
		                {
			                for ( int j = 'A'; j <= 'Z'; j++ )
			                {
				                gCharMap[j].byte = tolower(j);
			                }
		                }
	                }
                    break;

                case CONFIG_TYPE_STRING: symbol = malloc( sizeof( tSymbolEntry ));
	                if ( symbol != NULL)
	                {
		                symbol->name     = name;
		                symbol->mappedTo = config_setting_get_string( element );

		                int           j    = 0;
		                unsigned char k;
		                unsigned char next;
		                unsigned char prev = '\0';

		                /* pick the first char as the byte to use in the map */
		                unsigned char symbolByte = symbol->mappedTo[0];
		                do
		                {
			                k = symbol->mappedTo[j++];
			                if ( k != '\0' )
			                {
				                next = symbol->mappedTo[j];

				                /* check for a range - a dash bracketed by two characters */
				                if ( k != '-' || prev == '\0' || next == '\0' )
				                {
					                gCharMap[k].byte   = symbolByte;
					                gCharMap[k].symbol = symbol;
				                }
				                else
				                {
					                /* if it's a dash, and it's not at the beginning or end of mappedTo,
									 * then process the range of characters between start and end */
					                for ( int l = prev; l <= next; l++ )
					                {
						                gCharMap[l].byte   = symbolByte;
						                gCharMap[l].symbol = symbol;
					                }
				                }
				                prev = k;
			                }
		                } while ( k != '\0' );


		                symbol->next = gSymbolRoot;
		                gSymbolRoot = symbol;
	                }
                    break;

                default:
                    printError( "unsupported mapping type in file \"%s\" at line %d",
                                 config_setting_source_file( mapping ),
                                 config_setting_source_line( mapping ) );
                    break;
                }
                i++;
            }

			fprintf( gOutputFile, "\ntypedef enum {\n    k%sNoMatch          = 1,\n", gPrefix );
	        symbol = gSymbolRoot;
			while (symbol != NULL)
			{
				fprintf( gOutputFile, "    k%s%-16s = \'%c\'%s\n", gPrefix, symbol->name, symbol->mappedTo[0], (symbol->next != NULL)? "," : "" );
				symbol = symbol->next;
			}
	        fprintf( gOutputFile, "} t%sMapping;\n\n", gPrefix );

			printMap();

	        symbol = gSymbolRoot;
			gSymbolRoot = NULL;
			while (symbol != NULL)
			{
				tSymbolEntry * next;
				next = symbol->next;
				free( symbol );
				symbol = next;
			}
        }
        else
        {
            printError( "mapping is not a group in file \"%s\" at line %d",
                        config_setting_source_file( mapping ),
                        config_setting_source_line( mapping ) );
        }
    }
    return result;
}

int processKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;
	config_setting_t * element;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
			int i = 0;
			const char * keyword;
			const char * hashword;
			char buffer[100];
			int keywordCount = keywords->value.list->length;

			fprintf( gOutputFile, "\ntypedef enum {\n" );
			while ((element = config_setting_get_elem( keywords, i )) != NULL)
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';
						hashword = (*src == ',') ? ++src : keyword;

						tHash hash = 0;
						src = hashword;
						while (*src != '\0' )
						{
							hash = hashChar( hash, *src );
							src++;
						}
						fprintf( gOutputFile, "    k%s%-16s = 0x%016lx%c    /* %s */\n",
								gPrefix, buffer, hash, (i+1 < keywordCount)? ',' : ' ', hashword );
					}
				}
				else
				{
					printError( "keyword must be a string, in file \"%s\" at line %d",
					            config_setting_source_file( element ),
					            config_setting_source_line( element ) );
				}
				i++;
			}
			fprintf( gOutputFile, "} t%sKeyword;\n\n", gPrefix );
		}
		else
		{
			printError( "\'keywords\' must be a array, in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}

int printInverseKeywords( config_t * config )
{
	int result = 0;
	config_setting_t * keywords;
	config_setting_t * element;

	keywords = config_lookup(config, "keywords");
	if (keywords != NULL)
	{
		if ( config_setting_is_array( keywords ) )
		{
			int i = 0;
			const char * keyword;
			char buffer[100];

			fprintf( gOutputFile, gInverseMapPrefix, gPrefix, gPrefix, gPrefix );
			while ((element = config_setting_get_elem( keywords, i )) != NULL)
			{
				if ( config_setting_type( element ) == CONFIG_TYPE_STRING )
				{
					keyword = config_setting_get_string( element );
					if ( keyword != NULL )
					{
						const char * src = keyword;
						char * dest = buffer;
						int cnt = sizeof( buffer );

						while ( cnt > 1 && *src != '\0' && *src != ',' )
						{
							*dest++ = *src++;
							--cnt;
						}
						*dest = '\0';

						fprintf( gOutputFile, "    { k%s%-16s, \"%s\" },\n",
						         gPrefix, buffer, buffer );
					}
				}
				else
				{
					printError( "keyword must be a string, in file \"%s\" at line %d",
					            config_setting_source_file( element ),
					            config_setting_source_line( element ) );
				}
				i++;
			}
			fprintf( gOutputFile, "    { 0, NULL }\n};\n\n" );
		}
		else
		{
			printError( "\'keywords\' must be a array, in file \"%s\" at line %d",
			            config_setting_source_file( keywords ),
			            config_setting_source_line( keywords ) );
		}
	}
	return result;
}


int processStructure( config_t * config )
{
	int result;

	config_lookup_string( config, "prefix", &gPrefix );

    /* first, we need to build the character mapping */
    result = processMapping( config );

    /* array is complete, so now we can generate the hashes */
    if ( result == 0 )
    {
    	result = processKeywords( config );
    }
    if ( result == 0 )
    {
    	result = printInverseKeywords( config );
    }

	fprintf( gOutputFile, gHashFunction, gPrefix, _hash_factor, gPrefix );

    return result;
}

int processHashFile( const char *filename )
{
    int result = 0;
    struct config_t config;

    config_init( &config );

    if ( config_read_file( &config, filename ) == CONFIG_TRUE )
	{
		fprintf( gOutputFile, gHeaderPrefix, gExecutableName, filename );
		result = processStructure( &config );
		fprintf( gOutputFile, "%s", gHeaderSuffix );
	}
    else
    {
        /* result is 0 only if the error message was output successfully  */
        /* note that config_error_file returns NULL if file doesn't exist */
        result = printParseError( config_error_text( &config ),
                                  config_error_file( &config ),
                                  config_error_line( &config ) );
        if ( result != 0 )
        {
            printError( "unable to parse \'%s\': %s", filename, config_error_text( &config ) );
        }
        result = -1;
    }

    config_destroy( &config );

    return result;
}

int main( int argc, char * argv[] )
{
    int result = 0;

    gExecutableName = strrchr( argv[0], '/' );
    /* If we found a slash, increment past it. If there's no slash, point at the full argv[0] */
    if ( gExecutableName++ == NULL )
        { gExecutableName = argv[0]; }

    gOutputFile = stdout;

    /* the global arg_xxx structs above are initialised within the argtable */
    void * argtable[] =
    {
        gOption.help    = arg_litn(  NULL, "help",      0, 1, "display this help (and exit)"),
        gOption.version = arg_litn(  NULL, "version",   0, 1, "display version info (and exit)"),
	    gOption.extn    = arg_strn(  "x",  "extension", "<extension>",  0, 1, "set the extension to use for output files"),
        gOption.file    = arg_filen( NULL, NULL,        "<file>", 1, 999, "input files"),

        gOption.end     = arg_end( 20 )
    };

    int nerrors = arg_parse( argc, argv, argtable );

    if ( gOption.help->count > 0 ) 	/* special case: '--help' takes precedence over everything else */
    {
        fprintf( stdout, "Usage: %s", gExecutableName );
        arg_print_syntax( stdout, argtable, "\n" );
        fprintf( stdout, "process hash file into a header file.\n\n" );
        arg_print_glossary( stdout, argtable, "  %-25s %s\n" );
        fprintf( stdout, "\n" );

        result = 0;
    }
    else if ( gOption.version->count > 0 )   /* ditto for '--version' */
    {
        fprintf( stdout, "%s, version %s\n", gExecutableName, "(to do)" );
    }
    else if (nerrors > 0) 	/* If the parser returned any errors then display them and exit */
    {
        /* Display the error details contained in the arg_end struct.*/
        arg_print_errors( stdout, gOption.end, gExecutableName );
        fprintf( stdout, "Try '%s --help' for more information.\n", gExecutableName );
        result = 1;
    }
    else
    {
        result = 0;
        int i = 0;

        gOutputFile = NULL;

	    const char * extension = ".h";
	    if ( gOption.extn->count != 0 )
	    {
		    extension = *gOption.extn->sval;
	    }

        while ( i < gOption.file->count && result == 0 )
        {
	        char output[FILENAME_MAX];
	        strncpy( output, gOption.file->filename[i], sizeof(output) );


	        char * p = strrchr( output, '.' );
            if ( p != NULL )
	        {
		        strncpy( p, extension, &output[ sizeof(output) - 1 ] - p );
	        }

	        gOutputFile = fopen( output, "w" );
	        if ( gOutputFile == NULL)
	        {
		        fprintf( stderr, "### unable to open \'%s\' (%d: %s)\n",
		                 output, errno, strerror(errno) );
		        result = errno;
	        }

			if ( result == 0 )
			{
				result = processHashFile( gOption.file->filename[i] );
			}
            i++;

			fclose( gOutputFile );
        }
    }

    /* release each non-null entry in argtable[] */
    arg_freetable( argtable, sizeof(argtable) / sizeof(argtable[0]) );

    return result;
}
